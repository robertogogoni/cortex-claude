/**
 * Cortex - Claude's Cognitive Layer - Docs Writer
 *
 * LADS Principle: Documenting
 * Auto-generates documentation:
 * - Changelog for all system changes
 * - Decision log for config changes
 * - Skill documentation
 * - Rollback records
 */

'use strict';

const fs = require('fs');
const path = require('path');
const { getTimestamp, expandPath } = require('../types.cjs');

// =============================================================================
// DOCS WRITER
// =============================================================================

class DocsWriter {
  /**
   * @param {Object} options
   * @param {string} options.docsPath - Base path for docs
   * @param {boolean} options.enabled - Whether auto-docs are enabled
   */
  constructor(options = {}) {
    this.docsPath = expandPath(options.docsPath || '~/.claude/memory/docs');
    this.enabled = options.enabled !== false;

    // File paths
    this.changelogPath = path.join(this.docsPath, 'changelog.md');
    this.decisionsPath = path.join(this.docsPath, 'decisions.md');
    this.skillsPath = path.join(this.docsPath, 'skills');

    // Ensure directories exist
    this._ensureDirs();
  }

  /**
   * Ensure documentation directories exist
   */
  _ensureDirs() {
    const dirs = [this.docsPath, this.skillsPath];
    for (const dir of dirs) {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true, mode: 0o700 });
      }
    }
  }

  /**
   * Read a doc file or return empty string
   * @param {string} filePath
   * @returns {string}
   */
  _readDoc(filePath) {
    try {
      if (fs.existsSync(filePath)) {
        return fs.readFileSync(filePath, 'utf8');
      }
    } catch (e) {
      console.error(`[DocsWriter] Failed to read ${filePath}:`, e.message);
    }
    return '';
  }

  /**
   * Write a doc file atomically
   * @param {string} filePath
   * @param {string} content
   * @returns {boolean}
   */
  _writeDoc(filePath, content) {
    try {
      const tempPath = `${filePath}.tmp.${process.pid}`;
      fs.writeFileSync(tempPath, content, { mode: 0o600 });
      fs.renameSync(tempPath, filePath);
      return true;
    } catch (e) {
      console.error(`[DocsWriter] Failed to write ${filePath}:`, e.message);
      return false;
    }
  }

  /**
   * Format timestamp for display
   * @param {string} timestamp
   * @returns {string}
   */
  _formatDate(timestamp = null) {
    const date = timestamp ? new Date(timestamp) : new Date();
    return date.toISOString().replace('T', ' ').slice(0, 19);
  }

  // ===========================================================================
  // CHANGELOG
  // ===========================================================================

  /**
   * Get or create changelog with header
   * @returns {string}
   */
  _getChangelogContent() {
    let content = this._readDoc(this.changelogPath);

    if (!content) {
      content = `# Cortex - Claude's Cognitive Layer - Changelog

This file is auto-generated by Cortex's DocsWriter.

---

`;
    }

    return content;
  }

  /**
   * Add entry to changelog
   * @param {Object} entry
   * @returns {boolean}
   */
  addChangelogEntry(entry) {
    if (!this.enabled) return false;

    const content = this._getChangelogContent();
    const timestamp = this._formatDate();

    // Format entry
    const entryText = `
## ${timestamp}

**Type:** ${entry.type || 'change'}
${entry.component ? `**Component:** ${entry.component}` : ''}

${entry.description}

${entry.details ? `### Details\n${entry.details}` : ''}

---
`;

    // Prepend to changelog (newest first)
    const headerEnd = content.indexOf('---\n') + 4;
    const newContent = content.slice(0, headerEnd) + entryText + content.slice(headerEnd);

    return this._writeDoc(this.changelogPath, newContent);
  }

  /**
   * Log config evolution
   * @param {Object} evolution
   */
  logEvolution(evolution) {
    this.addChangelogEntry({
      type: 'config_evolution',
      component: 'ConfigEvolver',
      description: `Configuration evolved: ${evolution.rule}`,
      details: `- Path: \`${evolution.configPath}\`
- Old value: \`${JSON.stringify(evolution.oldValue)}\`
- New value: \`${JSON.stringify(evolution.newValue)}\`
- Reason: ${evolution.reason}
- Confidence: ${(evolution.confidence * 100).toFixed(1)}%`,
    });
  }

  /**
   * Log memory extraction
   * @param {Object} memory
   */
  logExtraction(memory) {
    this.addChangelogEntry({
      type: 'memory_extracted',
      component: 'ExtractionEngine',
      description: `New memory extracted: ${memory.summary || memory.type}`,
      details: `- Type: ${memory.type}
- Project: ${memory.projectHash || 'global'}
- Confidence: ${(memory.extractionConfidence * 100).toFixed(1)}%
- Tags: ${memory.tags?.join(', ') || 'none'}`,
    });
  }

  /**
   * Log system event
   * @param {string} event
   * @param {Object} details
   */
  logEvent(event, details = {}) {
    this.addChangelogEntry({
      type: 'system_event',
      component: details.component || 'Cortex',
      description: event,
      details: details.message || '',
    });
  }

  // ===========================================================================
  // DECISIONS LOG
  // ===========================================================================

  /**
   * Get or create decisions log with header
   * @returns {string}
   */
  _getDecisionsContent() {
    let content = this._readDoc(this.decisionsPath);

    if (!content) {
      content = `# Cortex - Claude's Cognitive Layer - Decision Log

This file tracks configuration decisions and their outcomes.
Auto-generated by Cortex's DocsWriter.

---

`;
    }

    return content;
  }

  /**
   * Add decision to log
   * @param {Object} decision
   * @returns {boolean}
   */
  addDecision(decision) {
    if (!this.enabled) return false;

    const content = this._getDecisionsContent();
    const timestamp = this._formatDate();

    const entryText = `
## ${decision.title || decision.decisionType}

**Date:** ${timestamp}
**Decision ID:** ${decision.id}
**Type:** ${decision.decisionType}

### Context
${decision.context?.intent ? `- Intent: ${decision.context.intent}` : ''}
${decision.context?.projectHash ? `- Project: ${decision.context.projectHash}` : ''}
${decision.context?.tags?.length ? `- Tags: ${decision.context.tags.join(', ')}` : ''}

### Choice
\`${decision.choice}\`

### Alternatives Considered
${decision.alternatives?.length ? decision.alternatives.map(a => `- ${a}`).join('\n') : '- None recorded'}

### Confidence
${(decision.confidence * 100).toFixed(1)}%

### Outcome
${decision.outcome?.status === 'resolved'
    ? `- Useful: ${decision.outcome.useful === true ? '✅ Yes' : decision.outcome.useful === false ? '❌ No' : '❓ Unknown'}
- Reason: ${decision.outcome.reason || 'Not specified'}`
    : '⏳ Pending'}

---
`;

    const headerEnd = content.indexOf('---\n') + 4;
    const newContent = content.slice(0, headerEnd) + entryText + content.slice(headerEnd);

    return this._writeDoc(this.decisionsPath, newContent);
  }

  /**
   * Update decision with outcome
   * @param {string} decisionId
   * @param {Object} outcome
   */
  updateDecisionOutcome(decisionId, outcome) {
    if (!this.enabled) return false;

    const content = this._readDoc(this.decisionsPath);
    if (!content) return false;

    // Find and update the decision
    const pattern = new RegExp(
      `(\\*\\*Decision ID:\\*\\* ${decisionId}[\\s\\S]*?### Outcome\\n)([\\s\\S]*?)(\\n---)`
    );

    const outcomeText = `- Useful: ${outcome.useful === true ? '✅ Yes' : outcome.useful === false ? '❌ No' : '❓ Unknown'}
- Reason: ${outcome.reason || 'Not specified'}
- Resolved: ${this._formatDate()}`;

    const newContent = content.replace(pattern, `$1${outcomeText}$3`);

    if (newContent !== content) {
      return this._writeDoc(this.decisionsPath, newContent);
    }

    return false;
  }

  // ===========================================================================
  // SKILL DOCUMENTATION
  // ===========================================================================

  /**
   * Generate documentation for a skill
   * @param {Object} skill
   * @returns {boolean}
   */
  documentSkill(skill) {
    if (!this.enabled) return false;

    const filename = `${skill.name.replace(/[^a-zA-Z0-9_-]/g, '-')}.md`;
    const filepath = path.join(this.skillsPath, filename);

    const content = `# ${skill.name}

> Auto-generated skill documentation

## Description

${skill.description || 'No description provided.'}

## Origin

- **Created:** ${this._formatDate(skill.createdAt)}
- **Source Session:** ${skill.sourceSessionId || 'Unknown'}
- **Confidence:** ${((skill.extractionConfidence || 0) * 100).toFixed(1)}%

## Triggers

${skill.triggers?.keywords?.length ? `### Keywords\n${skill.triggers.keywords.map(k => `- \`${k}\``).join('\n')}` : ''}

${skill.triggers?.patterns?.length ? `### Patterns\n${skill.triggers.patterns.map(p => `- \`${p}\``).join('\n')}` : ''}

${skill.triggers?.intent_phrases?.length ? `### Intent Phrases\n${skill.triggers.intent_phrases.map(p => `- "${p}"`).join('\n')}` : ''}

## Content

\`\`\`
${skill.content || 'No content available.'}
\`\`\`

## Usage Statistics

- **Times Used:** ${skill.usageCount || 0}
- **Success Rate:** ${((skill.usageSuccessRate || 0) * 100).toFixed(1)}%
- **Last Used:** ${skill.lastUsed || 'Never'}

## Metadata

- **Type:** ${skill.type || 'skill'}
- **Project:** ${skill.projectHash || 'Global'}
- **Tags:** ${skill.tags?.join(', ') || 'None'}
- **Status:** ${skill.status || 'active'}

---

*Last updated: ${this._formatDate()}*
`;

    return this._writeDoc(filepath, content);
  }

  /**
   * List documented skills
   * @returns {string[]}
   */
  listSkillDocs() {
    try {
      return fs.readdirSync(this.skillsPath)
        .filter(f => f.endsWith('.md'))
        .map(f => f.replace('.md', ''));
    } catch {
      return [];
    }
  }

  // ===========================================================================
  // ROLLBACK RECORDS
  // ===========================================================================

  /**
   * Log a rollback
   * @param {Object} rollback
   */
  logRollback(rollback) {
    this.addChangelogEntry({
      type: 'rollback',
      component: rollback.component || 'ConfigEvolver',
      description: `Configuration rolled back: ${rollback.rule || rollback.configPath}`,
      details: `- Path: \`${rollback.configPath}\`
- From: \`${JSON.stringify(rollback.rolledBackFrom)}\`
- To: \`${JSON.stringify(rollback.rolledBackTo)}\`
- Reason: ${rollback.reason || 'Manual rollback'}`,
    });
  }

  // ===========================================================================
  // UTILITIES
  // ===========================================================================

  /**
   * Get changelog entries (parsed)
   * @param {number} limit
   * @returns {Object[]}
   */
  getChangelogEntries(limit = 10) {
    const content = this._readDoc(this.changelogPath);
    if (!content) return [];

    // Simple parsing: split by --- and extract entries
    const entries = [];
    const sections = content.split(/\n---\n/).slice(1, -1); // Skip header and trailing

    for (const section of sections.slice(0, limit)) {
      const lines = section.trim().split('\n');
      const dateMatch = lines[0]?.match(/## (.+)/);
      const typeMatch = lines.find(l => l.startsWith('**Type:**'))?.match(/\*\*Type:\*\* (.+)/);

      entries.push({
        date: dateMatch?.[1] || 'Unknown',
        type: typeMatch?.[1] || 'change',
        content: section.trim(),
      });
    }

    return entries;
  }

  /**
   * Get documentation statistics
   * @returns {Object}
   */
  getStats() {
    const changelogExists = fs.existsSync(this.changelogPath);
    const decisionsExists = fs.existsSync(this.decisionsPath);

    return {
      enabled: this.enabled,
      changelogExists,
      decisionsExists,
      skillsDocumented: this.listSkillDocs().length,
      docsPath: this.docsPath,
    };
  }

  /**
   * Enable/disable documentation
   * @param {boolean} enabled
   */
  setEnabled(enabled) {
    this.enabled = enabled;
  }
}

// =============================================================================
// EXPORTS
// =============================================================================

module.exports = {
  DocsWriter,
};
